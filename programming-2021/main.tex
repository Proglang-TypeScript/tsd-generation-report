% -*- coding: utf-8; -*-
\documentclass[english,cleveref,autoref,submission]{programming}
% Programming:
% The main part of the paper should not exceed 22 pages (in the
% provided style of the journal), but there is no limit for
% bibliography and appendices. The page limit for the main part of the
% paper is in place in order to keep the paper on focus and to avoid
% overloading the reviewers. Authors are encouraged to move important
% details to appendices, which may be consulted by the reviewers. In
% some cases, if authors feel that the main part requires
% substantially more pages, they should explain the reasons why in the
% additional comments field of the submission form; examples of these
% cases may include papers with substantial source code listings, and
% essays. Papers whose length is incommensurate with their
% contribution will be rejected. 

\usepackage[backend=biber]{biblatex}
\addbibresource{main.bib}

\usepackage{cleveref}
\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{positioning}

\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}

\newenvironment{changethis}{%
  \begin{tcolorbox}[breakable,notitle,boxrule=0pt,colback=blue!20,colframe=blue!20]}{%
  \end{tcolorbox}}

\input{macros}

\definecolor{backgroundgray}{rgb}{.94,.94,.94}
\definecolor{lightgray}{rgb}{.35,.35,.5}
\definecolor{darkgray}{rgb}{.2, .2, .2}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\newcommand{\secref}[1]{Section~\ref{#1} - \nameref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\coderef}[1]{Listing~\ref{#1}}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, undefined,const},
  keywordstyle=\color{black}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{black}\bfseries,
  identifierstyle=\color{darkgray},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{lightgray}\slshape,
  stringstyle=\color{darkgray}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{TypeScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, undefined,const},
  keywordstyle=\color{black}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this, declare, constructor, namespace, interface},
  ndkeywordstyle=\color{black}\bfseries,
  identifierstyle=\color{darkgray},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{lightgray}\slshape,
  stringstyle=\color{darkgray}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   backgroundcolor=\color{backgroundgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=none,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false
}

\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%%\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Generation of TypeScript Declaration Files from JavaScript Code}

% \titlerunning{Dummy short title}%optional, please use if title is longer than one line

\author{Fernando Cristiani}
\authorinfo{contact \email{fc@example.org}}
\affiliation{Hochschule Karlsruhe, Germany }

\author{Peter Thiemann}
\authorinfo{\email{thiemann@informatik.uni-freiburg.de}}
\affiliation{Universit√§t Freiburg, Germany}

\keywords{JavaScript, TypeScript, Dynamic Analysis, Declaration
  Files}%TODO mandatory; please add comma-separated list of 1--5 keywords

%%%%%%%%%%%%%%%%%%
%% These data MUST be filled for your submission. (see 5.3)
\paperdetails{
  %% perspective options are: art, sciencetheoretical, scienceempirical, engineering.
  %% Choose exactly the one that best describes this work. (see 2.1)
  perspective=science-empirical,
  %% State one or more areas, separated by a comma. (see 2.2)
  %% Please see list of areas in http://programming-journal.org/cfp/
  %% The list is open-ended, so use other areas if yours is/are not listed.
  area={General-purpose programming, Web programming},
  %% You may choose the license for your paper (see 3.)
  %% License options include: cc-by (default), cc-by-nc
  % license=cc-by,
}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%
%% These data are provided by the editors. May be left out on submission.
%\paperdetails{
%  submitted=2016-08-10,
%  published=2016-10-11,
%  year=2016,
%  volume=1,
%  issue=1,
%  articlenumber=1,
%}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Please go to https://dl.acm.org/ccs/ccs.cfm and generate your Classification
% System [view CCS TeX Code] stanz and copy _all of it_ to this place.
%% From HERE
%%% !!! REVISE
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002944.10011122.10003459</concept_id>
<concept_desc>General and reference~Computing standards, RFCs and guidelines</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10010405.10010476.10010477</concept_id>
<concept_desc>Applied computing~Publishing</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Software notations and tools}
\ccsdesc[100]{Software and its engineering~General programming languages}

% To HERE
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Developers are starting to write large and complex applications in
TypeScript, a typed dialect of JavaScript. TypeScript applications
integrate JavaScript libraries via typed descriptions of their APIs
called declaration files. DefinitelyTyped is the standard public
repository for these files.
The repository is maintained manually by volunteers, which
is error prone and time consuming. Discrepancies between a
declaration file and the JavaScript implementation lead to
incorrect feedback from the TypeScript IDE and thus to incorrect uses
of the underlying JavaScript library.

This work presents \texttt{dts-generate}, a tool that generates
TypeScript declaration files for JavaScript libraries uploaded to the \NPM{}
registry. It extracts code examples from the documentation written by
the developer, executes the library driven by the examples, gathers
run-time information, and generates a declaration file based on this
information. To evaluate the tool, 244 declaration files were generated and 82 were
compared with the corresponding declaration file provided on DefinitelyTyped. 52 files presented positive results, having no differences at all or differences that can be solved by modifying the code examples accordingly.

\end{abstract}

\section{Introduction}
\label{sec:introduction}
JavaScript is the most popular language for writing web
applications \cite{github-statistics}. It is also increasingly used
for back-end applications running in \NodeJS{}, a JavaScript-based
server-side platform. JavaScript is appealing to developers because
its forgiving dynamic typing enables 
them to create simple pieces of code very quickly and proceed on a
trial-and-error basis.

JavaScript was never intended to be more than a
scripting language and thus lacks features for maintaining and evolving large
codebases. However, nowadays developers create large and complex
applications in JavaScript. 
Mistakes such as mistyped property
names and misunderstood or unexpected type coercions cause developers
to spend a significant amount of time in debugging. There is ample
evidence for such mishaps. For example, a 
JavaScript code blog\footnote{\url{https://wtfjs.com}} collects experiences
from developers facing unexpected situations while programming in
JavaScript. \coderef{code:introduction-javascript-wtfs} exposes some
of these unintuitive JavaScript behaviors. 

\begin{lstlisting}[
    caption={\textbf{Unintuitive JavaScript behavior} Falsy values, \lstinline!typeof!, \lstinline!null! and \lstinline!undefined! operators and type coercion},
    language=JavaScript,
	label=code:introduction-javascript-wtfs,
    float=bp,
    captionpos=b
]
"0" == false; // true
true == "1.00"; // true
false == "    \n\r\t     "; // true
false == []; // true
0 == []; // true
null == undefined; // true
[1] + 1; //'11'
[2] == "2"; // true
null + undefined + [1, 2, 3] // 'NaN1,2,3'
"hello world".lenth + 1 // NaN | note 'lenth' instead of 'length'
[1, 15, 20, 100].sort() // [ 1, 100, 15, 20 ]
typeof null; // object
null instanceof Object; // false
"01" < "00100"; // false
\end{lstlisting}
% pjt: why unexpected? 

The cognitive load produced by these behaviors is mitigated in languages that use
build tools based on type information. This insight motivated the
creation of TypeScript, a superset of JavaScript with expressive type
annotations \cite{typescript}. It has become a widely used alternative
among JavaScript developers, because it incorporates features that are
helpful for developing and maintaining large applications
\cite{DBLP:conf/icse/GaoBB17}. TypeScript enables the early detection
of several kinds of run-time errors and the integration of code intelligence
tools like autocompletion in an IDE.

Despite the advantages, it is unrealistic to expect the world to
switch to TypeScript in a day. Therefore, 
existing JavaScript libraries can be used in a TypeScript project by
adding a declaration file that contains a description of the library's
API in terms of types. 
The DefinitelyTyped repository~\cite{definitely-typed-repository} has
been created as a community effort to collect declaration files for
popular JavaScript libraries. At the time of writing it contains
declaration files for more than 6000 libraries.

Unfortunately, creation and maintenance for most declaration
files in DefinitelyTyped is conducted manually,
which is error prone and time consuming. As TypeScript takes a
declaration file at face value, discrepancies are not detected at
compile time and the resulting inaccuracies in autocompletion, say,
are confusing for the programmer.
As TypeScript does not perform any run-time 
checking of types, either,  discrepancies  between the declaration file
and its corresponding JavaScript library can lead to unexpected 
behavior and crashes. Such an experience can lead to developer
frustration, longish debugging sessions, and decreasing confidence in
the tool chain.

\subsection{Approach}
\label{sec:approach}


We aim to improve on this situation by providing a tool that generates
sound TypeScript declaration files automatically. To do so, we rely on the examples provided
as part of the documentation of a library. If these
examples are sufficiently rich, then our toolchain can generate
high-quality declaration files from them. This approach takes
advantage of 
best practices in the dynamic languages community which favors
examples and tests over writing out type signatures.

As an example, consider the NPM module
\texttt{abs} that
``computes the absolute path of an input''. Its documentation consists
of the following three examples\footnote{\url{https://www.npmjs.com/package/abs}}.
\begin{lstlisting}[language=JavaScript,numbers=none]
const abs = require("abs");
 
console.log(abs("/foo"));
// => "/foo"
 
console.log(abs("foo"));
// => "/path/to/where/you/are/foo"
 
console.log(abs("~/foo"));
// => "/home/username/foo"
\end{lstlisting}
From the examples, our tool generates a TypeScript declaration file,
which is equivalent to the declaration file provided in
DefinitelyTyped\footnote{\url{https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/abs/index.d.ts}}: 
\begin{lstlisting}[language=TypeScript,numbers=none]
export = Abs;
declare function Abs(input: string): string;
\end{lstlisting}
% \begin{description}
% \item[PJT: maybe later] Some previous work tackled the problem of improving
%   the quality of declaration files. Feldthaus et al
%   \cite{DBLP:conf/oopsla/FeldthausM14} search automatically for
%   mismatches between a declaration file and implementation
%   code. TSTest \cite{DBLP:journals/pacmpl/KristensenM17} adapted
%   feedback-directed random testing to detect discrepancies between a
%   declaration file and a JavaScript library. Tools like TSInfer and
%   TSEvolve~\cite{DBLP:conf/fase/KristensenM17} are designed for
%   assisting the creation of new declaration files and supporting the
%   evolution the declaration file when the corresponding JavaScript
%   library gets modified, respectively. They rely on an existing static
%   analyzer for JavaScript \cite{DBLP:conf/sas/JensenMT09}.  TypeScript
%   itself developed \texttt{dts-gen}, a tool that generates a
%   declaration file that is meant to be used as a \emph{starting point
%     for writing a high-quality declaration file} \cite{dts-gen}.
% \end{description}

Our tool \texttt{dts-generate} is a first step to explore the possibilities for
generating useful declaration files from code
examples. \texttt{dts-generate} comes with a framework that 
supports the generation of declaration files for an existing
JavaScript library published to the \NPM{} registry. The tool gathers
data flow and type information at run time to generate a declaration
file based on that information.

The novelty of our tool is twofold:
\begin{enumerate}
\item
  %% without the heavy lifting of static analysis
  We do not rely on static analysis, which is hard to implement
  soundly and precisely and which is prone to maintenance problems
  when keeping up with JavaScript's frequent language updates.
\item
  Instead we extract example code from the programmer's library
  documentation and rely on dynamic analysis to extract typed usage
  patterns for the library from the example runs.
\end{enumerate}
% The architecture supports the future incorporation of a Symbolic
% Execution Engine that expands the initial code base using the
% signatures in the declaration file. The iterative process of exploring
% new execution paths will refine the generated declaration file in each
% iteration. 

% Finally, we generated declaration files for 244 JavaScript libraries
% and evaluated them against the DefinitelyTyped repository. 

\subsection{Contributions}
\label{sec:contributions}


\begin{itemize}
% \item We introduce an architecture that supports generating TypeScript
%   Declaration Files for a given JavaScript Library using run-time
%   information. The architecture supports the future incorporation of a
%   Symbolic Execution Engine that expands the initial code base using
%   the signatures in the declaration file. The iterative process of
%   exploring new execution paths will refine the generated declaration
%   file in each iteration.
\item A framework that extracts code examples from the
  documentation of an \NPM{} package and collects run-time type
  information from running these examples (Sections~\ref{sec:initial-code-base}
  and~\ref{sec:run-time-information}). 

\item Design and implementation of the tool \texttt{dts-generate}, a command line
  application that generates a valid TypeScript declaration file for a
  specific \NPM{} package using run-time information (Section~\ref{sec:typescr-decl-file}).

\item A comparator for TypeScript declaration files (Section~\ref{sec:dts-compare}). This tool is
  necessary for evaluating our framework and also useful to detect
  incompatibilities when evolving JavaScript modules.
\item An evaluation of our framework (Sections~\ref{sec:dts-generate-evaluation}
  and~\ref{sec:results}). We examined all 6029 entries in 
  the DefinitelyTyped repository and found 244 sufficiently
  well-documented \NPM{} packages, on which we ran \texttt{dts-generate}
  and compared the outcome with the respective declaration file from the
  DefinitelyTyped repository. 
\end{itemize}

\section{Motivating Example}
\label{sec:motivating-example}
The \NPM{} package \texttt{glob-to-regexp} is a simple JavaScript library, which turns a
glob expression for matching filenames in the shell into a regular
expression\footnote{https://www.npmjs.com/package/glob-to-regexp}. It 
has about 9,900,000 weekly downloads and 188 \NPM{} packages depend on it. If
a developer creates or extends TypeScript code that depends on the
\texttt{glob-to-regexp} library, the TypeScript
compiler and IDE requires a declaration file for that library to
perform static checking and code completion, respectively. With
\texttt{dts-generate} we automatically generate a TypeScript
declaration file for \texttt{glob-to-regexp}. The tool downloads the \NPM{} 
package, runs the examples extracted from its documentation, gathers
run-time information, and generates a TypeScript declaration
file. The result is 
shown in \figref{fig:motivating-example-glob-to-regexp-vscode} and it is
ready for use in a TypeScript project. For example,  Visual Studio's
code completion runs properly with the generated file
(\figref{fig:motivating-example-glob-to-regexp-vscode}). If the
\texttt{glob-to-regexp} package gets modified in the future, a new declaration
file can be generated automatically using
\texttt{dts-generate}. Our comparator tool can compare the new file
for incompatibilities with the previous declaration file.

\begin{figure}[tp]
  \centering
%  \begin{subfigure}{0.70\linewidth}
    \begin{lstlisting}[language=TypeScript,numbers=none]
export = GlobToRegexp;

declare function GlobToRegexp(glob: string, opts?: GlobToRegexp.I__opts): RegExp;
declare namespace GlobToRegexp {
  export interface I__opts {
    'extended'?: boolean;
    'globstar'?: boolean;
    'flags'?: string;
  }

}
    \end{lstlisting}
  % \end{subfigure}
  \begin{center}
    \includegraphics[width=0.8\linewidth]{motivating-example-glob-to-regexp-vscode.png}
  \end{center}

  \caption{\textbf{Declaration file for \texttt{glob-to-regexp}
      generated with \texttt{dts-generate}} - The interface is
    detected correctly. Optional parameters are detected. The
    declaration file is usable in Visual Studio
    Code\footnote{https://code.visualstudio.com}.} 
  \label{fig:motivating-example-glob-to-regexp-vscode}
\end{figure}

% After filling in some background information on declaration files,
% Section~\ref{sec:gener-typescr-decl} examines each step in the
% generation process in detail and refer back to this example for
% concreteness.

\section{TypeScript Declaration Files}
\label{sec:typescr-decl-files}

The declaration file shown in \figref{fig:motivating-example-glob-to-regexp-vscode}
describes a package with a single exported function. The first parameter is of type
\texttt{string} and the second one is an optional interface. TypeScript namespaces
organize types declared in a declaration file and avoid name clashes with other types
\cite{typescript-namespaces}. For example, the interface \texttt{I\_\_opts} declared in
\figref{fig:motivating-example-glob-to-regexp-vscode} is used as
\lstinline[language=TypeScript]{globToRegexp.I__opts} because it is declared within a
namespace.


This file is an instance of one of the standard templates for writing
declaration
files\footnote{https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html}:
\textbf{module}, \textbf{module-class}, and
\textbf{module-function}. 
Each template corresponds to a different way of describing the exports
of a JavaScript library. The choice of the template depends on the
organization of the underlying JavaScript library:
\begin{description}
\item[module] several exported functions,
\item[module-class] a class-like structure,
\item[module-function] exactly one exported function.
\end{description}

\begin{lstlisting}[
    caption={Example for template \textbf{module-function}},
    language=bash,
	label=code:dts-generate-example,
    float,captionpos=b
]
$ ./dts-generate abs
$ cat output/abs/index.d.ts 
export = Abs;

declare function Abs(input: string): string;
\end{lstlisting}

\begin{figure}[tp]
  \centering
  \begin{subfigure}{0.48\linewidth}
    \begin{lstlisting}[language=JavaScript,numbers=none]
var greet = require("./greet-settings-module");

greet({
  greeting: "hello world",
  duration: 4000
});

greet({
  greeting: "hello world",
  color: "#00ff00"
});
    \end{lstlisting}
    \caption{Example for \texttt{module-function} template}
    \label{fig:example-module-function}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.48\linewidth}
    \begin{lstlisting}[language=TypeScript,numbers=none]
export = GreetSettingsModule;

declare function GreetSettingsModule(settings: GreetSettingsModule.I__settings): void;
declare namespace GreetSettingsModule {
  export interface I__settings {
    'greeting': string;
    'duration'?: number;
    'color'?: string;
  }

}
    \end{lstlisting}
    \caption{Declaration file for \texttt{module-function} template}
    \label{fig:template-module-function}
  \end{subfigure}

  \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=JavaScript,numbers=none]
var myLib = require("./greet-module");

var result = myLib.makeGreeting("hello, world");
console.log("The computed greeting is: " + result);

var goodbye = myLib.makeGoodBye();
console.log("The computed goodbye is: " + goodbye);    
      \end{lstlisting}
    \caption{Example for \texttt{module} template}
    \label{fig:example-module}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export function makeGreeting(str: string): string;
export function makeGoodBye(): string;        
      \end{lstlisting}
      \caption{Declaration file for \texttt{module} template}
      \label{fig:template-module}
    \end{subfigure}

    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=JavaScript,numbers=none]
var Greeter = require("./greet-classes-module.js");

var myGreeter = new Greeter("hello, world");
myGreeter.greeting = "howdy";
myGreeter.showGreeting();
      \end{lstlisting}
      \caption{Example for \texttt{module-class} template}
      \label{fig:example-class}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export = Greeter;

declare class Greeter {
  constructor(message: string);
  showGreeting(): void;
}

declare namespace Greeter {
}
      \end{lstlisting}
      \caption{Declaration file for \texttt{module-class} template}
      \label{fig:template-class}
    \end{subfigure}

  \caption{Example uses and declaration files for different templates}
  \label{fig:typescript-templates-by-example}
\end{figure}
 
The TypeScript project provides a guide on how to write high-quality declaration
files\footnote{https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html}. The guide
explains the main concepts through examples. We selected one example for each template
from the guide and
used \texttt{dts-generate} to generate a corresponding declaration file, as shown in
\figref{fig:typescript-templates-by-example}.

Like \texttt{dts-gen}, a TypeScript package that generates a template for a declaration
file, we determine the kind of declaration file by examining the provided example. If the
imported entity is used solely as a function as in Figure~\ref{fig:example-module-function}, the
generated declaration file follows the module-function template as shown in Figure~\ref{fig:template-module-function}.
If the example only accesses properties of the imported entity as in
Figure~\ref{fig:example-module}, we generate according to the module template (Figure~\ref{fig:template-module}).
If the imported entity is used with \lstinline/new/ to create new instances as in
Figure~\ref{fig:example-class}, we generate a module-class template (Figure~\ref{fig:template-class}).

The libraries \texttt{glob-to-regexp} as well as \texttt{abs} are both instances of the
\textbf{module-function} template.
Most libraries fall in one of these three categories. 
While it is possible to create a library of undetermined category, our selection is driven
by the examples in the documentation and 
hence reflects the developers intent.
% Run-time analysis proves useful in this case,
% since it is not sufficient to statically analyze the exported module. 


% \begin{figure}[tp]
%   \centering
%   \begin{subfigure}{0.80\linewidth}
%       \begin{lstlisting}[language=JavaScript]
% var multiPurposeModule = require('./multi-purpose-module');

% // module-function
% console.log(multiPurposeModule("John", "Doe"));
% // John Doe


% // module-class
% var m = new multiPurposeModule("Jane", "Doe");
% console.log(m.firstName + " - " + m.lastName);
% // Jane - Doe

% console.log(m.sayHello());
% // Hello, my name is Jane Doe

% // module
% console.log(multiPurposeModule.anotherFunction());
% // I am another function! 
%       \end{lstlisting}
%       \caption{index.js}
%     \end{subfigure}

%     \begin{subfigure}{0.80\linewidth}
%       \begin{lstlisting}[language=TypeScript,numbers=none]
% var multiPurposeModule = function(firstName, lastName) {
%   this.firstName = firstName;
%   this.lastName = lastName;

%   return firstName + " " + lastName;
% };

% multiPurposeModule.prototype.sayHello = function() {
%   return "Hello, my name is " + this.firstName + " " + this.lastName;
% };

% multiPurposeModule.anotherFunction = function() {
%   return "I am another function!";
% };

% module.exports = multiPurposeModule;   
%       \end{lstlisting}
%       \caption{multi-purpose-module/index.js}
%     \end{subfigure}
%   \caption{Example module that implements all three templates simultaneously}
%   \label{fig:multi-purpose-module-example}
% \end{figure}


\section{The Generation of TypeScript Declaration Files}
\label{sec:gener-typescr-decl}
This section gives an overview of our approach to generating
TypeScript declaration files from a JavaScript library packaged in
\NPM. \figref{fig:tsd_generation_method_block_diagram} gives a rough
picture of the inner working of our tool \texttt{dts-generate}. The
input is an \NPM{} package and the output is a TypeScript declaration
file for the package if it is ``sufficiently documented'', which we
substantiate in the next subsection.

% We introduce \texttt{dts-generate}, a command line tool which
% generates a valid TypeScript Declaration File for a specific
% JavaScript Library uploaded to the \NPM{} Registry, as explained in
% \figref{fig:tsd_generation_method_block_diagram}. The tool is intended
% to be used on existing, published \NPM{} packages. The generated
% output TypeScript declaration file is a valid file which can be used
% for development and uploaded to the DefinitelyTyped Repository. 

\begin{figure}[tp]
    \centering
    \includegraphics[width=1\linewidth]{dts-generate-block-diagram.pdf}
    \caption[dts-generate - Architecture overview]{\textbf{dts-generate - Architecture
        overview} - The initial code base is retrieved from the \NPM{} package's
      repository.
      Run-time information is gathered driven by example code.
      A TypeScript Declaration File is generated using run-time
      information.
      % A Symbolic Execution Engine creates test cases based on the generated
      % Declaration File and via a feedback loop enriches the code base until the stopping
      % criteria is reached.
      % The final TypeScript Declaration File gets returned.
      % Feedback
      % loop through the Symbolic Execution Engine was not implemented. It can be added in a
      % future to the existing architecture, without modifying the working blocks.
    } 
    \label{fig:tsd_generation_method_block_diagram}
  \end{figure}

As \texttt{dts-generate} is based on run-time information, 
exemplary code fragments that execute the JavaScript library are
needed to obtain 
significant run-time information from running the instrumented library
code.


The examples and the code base of the library are instrumented with
Jalangi \cite{DBLP:conf/sigsoft/SenKBG13} to gather data flow
information and type information at run time. Jalangi is a configurable
framework for dynamic analysis of JavaScript. It provides several
analysis modules that we extended as needed to retrieve the required
run-time information, which is then saved in a JSON file. 

A second independent block uses the run-time information to generate a
TypeScript declaration file. It infers the overall structure of the JavaScript
library, its interfaces, and the types from the run-time information. 
The resulting declaration file is ready for use in the development
process. Its contents mimic the usage of the library in the example
code fragments and matches the structure of the
JavaScript library under analysis, so that the JavaScript code
generated after compiling the TypeScript code runs without
interface-related errors.

The command-line interface is inspired by the \texttt{dts-gen} tool
\cite{dts-gen}. \coderef{code:dts-generate-example} shows
that invoking the package is very simple. Its only required
argument is the name of the module published to the \NPM{} registry. 


\subsection{Initial Code Base}
\label{sec:initial-code-base}

To extract run-time information from a JavaScript library, it is
necessary, by definition, to actually execute the code, because the
analysis modules provided by Jalangi to gather information are only
triggered if the instrumented code gets executed.

There are several options to obtain code fragments that drive the
library code:
\begin{enumerate}
\item\label{item:1} execute code that imports the library;
\item\label{item:2} execute the test cases that come with the library;
\item\label{item:3} execute code fragments extracted from the library documentation.
\end{enumerate}

Option~\ref{item:1} does not solve our problem, it just delegates it
to the importing library, which also needs code to drive it. Moreover,
it is costly to download and instrument another package.

We considered option~\ref{item:2} under the assumption that most
libraries would come with test cases. However, there is no standard
for testing JavaScript code so that test cases were difficult to reap
from the \NPM{} packages: they use different directory structures,
employ differing (or no) testing tools, or do not have tests
at all. Moreover, developers try to cover edge cases or to trigger errors by using illegal
input values in their tests. Such tests are not really useful for describing a library
from the consumer's point of view. For example, a developer might write a test invoking a
function with \texttt{null} just to validate that it throws an error in such scenario. 

In the end, option~\ref{item:3} was the most viable even though there
is no standard for documentation, either. However, almost all repositories
contain README files where the library authors briefly describe in prose what
the code does, which problem it solves, how to install the
application, how to build the code, etc. It is very common that
developers provide code examples in the README files to show how the
library works and how to use it. These code fragments represent common usage cases rather
than stress-testing the implementation (the problem of
option~\ref{item:2}) because they are meant to be instructive to users of the package.  


Obtaining code examples for a specific \NPM{} package is done in three steps.
\begin{itemize}
\item Obtain the  repository's URL with the command
  \texttt{npm view <PACKAGE> repository.url}

\item Retrieve the README file from the top-level directory of the repository.

\item Extract the code examples from the README file. To this end,
  observe that README files are
  written using Markdown\footnote{\url{https://www.markdownguide.org}}, a
  popular markup language, where
  code examples are presented in code blocks labeled with the programming
  language, so that syntax highlighting is done correctly. Hence, we
  retrieve the code examples from code blocks labeled \texttt{js} or
  \texttt{javascript}, which both stand for JavaScript in
  Markdown.
\end{itemize}

\coderef{code:code-example-extracted-motivating-example} shows
the examples extracted from  the README file of the \texttt{glob-to-regexp} package in
that way.

\begin{lstlisting}[
  caption={Extracted example code for the \texttt{glob-to-regexp} package},
  language=JavaScript,
  label=code:code-example-extracted-motivating-example,
  float,captionpos=b
]
var globToRegExp = require('glob-to-regexp');
var re = globToRegExp("p*uck");
re.test("pot luck"); // true
re.test("pluck"); // true
re.test("puck"); // true

re = globToRegExp("*.min.js");
re.test("http://example.com/jquery.min.js"); // true
re.test("http://example.com/jquery.min.js.map"); // false

re = globToRegExp("*/www/*.js");
re.test("http://example.com/www/app.js"); // true
re.test("http://example.com/www/lib/factory-proxy-model-observer.js"); // true

// Extended globs
re = globToRegExp("*/www/{*.js,*.html}", { extended: true });
re.test("http://example.com/www/app.js"); // true
re.test("http://example.com/www/index.html"); // true
\end{lstlisting}

Obtaining the code fragments from the examples provided in the
README files of the repository proved to be an
appropriate and pragmatic way of extracting the developer's
intention and provides a useful initial code base with meaningful
examples, thus avoiding possible cold start problems.

\subsection{Run-time Information Gathering}
\label{sec:run-time-information}
The Runtime Information block described in
\figref{fig:tsd_generation_method_block_diagram} gathers
type-related information as well as usage-related information for each function parameter.
For example,

\begin{itemize}
  \item Function \lstinline{f} was invoked where parameter
    \lstinline{a} held a value of type \lstinline{string} and
    \lstinline{b} a value of type \lstinline{number}. 
  \item Property \lstinline{foo} of parameter \lstinline{a} of
    function \lstinline{f} was accessed within the function. 
  \item Parameter \lstinline{a} of function \lstinline{f} was used as
    operand for operator \lstinline{==}. 
\end{itemize}

The dynamic analysis framework Jalangi is used for gathering this kind of
information. The configurable analysis modules enable
programming custom callbacks that can get triggered with virtually any
JavaScript event. Our instrumentation observes the following events: 
\begin{itemize}
  \item binary operations, like \lstinline{==}, \lstinline{+}, or
    \lstinline{===};
  \item variable declarations;
  \item function, method, or constructor invocations;
  \item access to an object's property;
  \item unary operations, like \lstinline{!} or \lstinline{typeof}.
\end{itemize}

The implementation stores these observations as entities called
\texttt{interactions}. They are used for translating, modifying, and
aggregating Jalangi's raw event information to get an application-specific data representation. Each function invocation is stored as a \texttt{FunctionContainer} which contains an \texttt{ArgumentContainer} for each argument. Each \texttt{ArgumentContainer} contains the name and index of the argument and a collection of \texttt{interactions}. The interaction \texttt{getField} gets triggered whenever a property of an object gets accessed and it tracks the name of the accessed field. The invocation of an object's method is tracked with the \texttt{methodCall} interaction. The \texttt{usedAsArgument} interaction gets triggered when an argument is used in the invocation of a function. The \texttt{followingInteractions} property is used for inferring nested interfaces. It is an array that recursively records \texttt{interactions} on the return value of \texttt{getField} or \texttt{methodCall}.

We wrap each function's argument in a wrapper object, which enables to store meta-information and greatly simplifies the mapping of an observation with the corresponding \texttt{ArgumentContainer} or \texttt{interaction}. We use the original values for critical operators such as \texttt{===} or \texttt{typeof}, for which wrapper objects would modify the behavior of the code.

The property \texttt{requiredModule} stores the name of the module that declared the invoked function. If a function is explicitly exported by the module, the property \texttt{isExported} will be set to \texttt{true} when it is invoked. If a function of an exported object is invoked, \texttt{isExported} will be \texttt{false} and \texttt{requiredModule} will contain the name of the required module.

The run-time information is saved as a JSON file that can be used for later
processing. The instrumentation tool is written in JavaScript and runs in \NodeJS{} in a
Docker container.   

\subsection{TypeScript Declaration File Generation}
\label{sec:typescr-decl-file}
%\paragraph*{Overview}

The next step in the pipeline after gathering the run-time information is
the generation of the declaration file (cf.\
\figref{fig:tsd_generation_method_block_diagram}). It is a lightweight,
simple, and fast application, which solely relies on the run-time
information gathered in the previous step.
% The tool itself is written in TypeScript and runs in a
% Docker container in \NodeJS.  

Instead of analyzing the shape of the exported module, we inspect how the module is used
to choose between the templates. We analyze the properties \texttt{isExported},
\texttt{requiredModule} and \texttt{isConstructor} from the run-time JSON to distinguish
between \texttt{module-class} and \texttt{module-function}. If a function is invoked and
it is imported from the module we are analyzing we infer the template
\texttt{module-class} or \texttt{module-function}. We choose \texttt{module-class} if the
function is used as a constructor. Otherwise, we choose
\texttt{module-function}.
If no function is invoked, we use the \texttt{module}
template.
% \figref{fig:dts-generate-choose-templates} exposes this logic using the example
% provided in \figref{fig:multi-purpose-module-example}.

% \begin{figure}[tp]
%   \centering
%   \begin{subfigure}{0.48\linewidth}
%     \begin{lstlisting}[language=JavaScript]
% var multiPurposeModule = require('./multi-purpose-module');

% multiPurposeModule("John", "Doe");
% // John Doe
%     \end{lstlisting}
%     \caption{Example module \texttt{multi-purpose-module} used as \texttt{module-function}}
%   \end{subfigure}
%   \hfill
%   \begin{subfigure}{0.48\linewidth}
%     \begin{lstlisting}[language=TypeScript,numbers=none]
% export = MultiPurposeModule;

% declare function MultiPurposeModule(firstName: string, lastName: string): string;
%     \end{lstlisting}
%     \caption{Generated declaration file with \texttt{module-function} template}
%   \end{subfigure}

%   \begin{subfigure}{0.48\linewidth}
%     \begin{lstlisting}[language=JavaScript]
% var multiPurposeModule = require('./multi-purpose-module');

% var m = new multiPurposeModule("Jane", "Doe");
% var fullName = m.firstName + " - " + m.lastName;
% // Jane - Doe

% m.sayHello();
% // Hello, my name is Jane Doe
%     \end{lstlisting}
%     \caption{Example module \texttt{multi-purpose-module} used as \texttt{module-class}}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.48\linewidth}
%       \begin{lstlisting}[language=TypeScript,numbers=none]
% export = MultiPurposeModule;

% declare class MultiPurposeModule {
%   constructor(firstName: string, lastName: string);
%   sayHello(): string;
% }

% declare namespace MultiPurposeModule {
% }
%       \end{lstlisting}
%       \caption{Generated declaration file with \texttt{module-class} template}
%     \end{subfigure}


%     \begin{subfigure}{0.48\linewidth}
%       \begin{lstlisting}[language=JavaScript]
% var multiPurposeModule = require('./multi-purpose-module');

% multiPurposeModule.anotherFunction();
% // I am another function!
%       \end{lstlisting}
%       \caption{Example module \texttt{multi-purpose-module} used as \texttt{module}}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.48\linewidth}
%       \begin{lstlisting}[language=TypeScript,numbers=none]
% export function anotherFunction(): string;
%       \end{lstlisting}
%       \caption{Generated declaration file with \texttt{module} template}
%     \end{subfigure}

%   \caption{Different ways of using example module presented in \figref{fig:multi-purpose-module-example}. \texttt{dts-generate} generates infers the correct template for each case. The JavaScript implementation of the module remained unmodified for each example.}
%   \label{fig:dts-generate-choose-templates}
% \end{figure}


\begin{figure}[tp]
  \centering
  \begin{subfigure}{0.48\linewidth}
    \begin{lstlisting}[language=TypeScript,numbers=none]
export function v1(str: string): boolean;
export function v2(str: string): boolean;
export function v3(str: string): boolean;
export function v4(str: string): boolean;
export function v5(str: string): boolean;
    \end{lstlisting}
    \caption{is-uuid/index.d.ts - Generated}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.48\linewidth}
    \begin{lstlisting}[language=TypeScript,numbers=none]
export function v1(value: string): boolean;
export function v2(value: string): boolean;
export function v3(value: string): boolean;
export function v4(value: string): boolean;
export function v5(value: string): boolean;
export function nil(value: string): boolean;
export function anyNonNil(value: string): boolean;
    \end{lstlisting}
    \caption{is-uuid/index.d.ts - DefinitelyTyped}
  \end{subfigure}

  \caption{Results for \textbf{module}  module \texttt{is-uuid}}
  \label{fig:experiments-results-module-is-uuid}
\end{figure}

We implemented only basic TypeScript features and we focused our effort in building an
end-to-end solution that generates valid and useful declaration files. Only the basic
types \texttt{string}, \texttt{number}, \texttt{boolean}, its union and the optional type were considered
both for function parameters and interface properties. Common types such as
\texttt{any}, arrays, function callbacks, tuples, intersections and features such as
generics, index signatures were not implemented.

Each declaration file in the DT repository was tagged with
\texttt{dts-parse}. We summarized the results in Table~\ref{tab:dts-parse-stats}. We based our decisions of prioritizing particular features on these results.

\begin{table}[tp]
  \begin{center}
    \begin{tabular}{ |c|c|c| } 
      \hline
      \textbf{TypeScript feature} & \textbf{Count Declaration Files} & \textbf{\%} \\ 
      \hline
      string & 5086 & 76.50\% \\
      optional-parameter & 4915 & 73.93\% \\
      boolean & 3891 & 58.53\% \\
      number & 3699 & 55.64\% \\
      void & 3548 & 53.37\% \\
      type-union & 3456 & 51.99\% \\
      type-function & 3286 & 49.43\% \\
      type-array & 3264 & 49.10\% \\
      type-any & 3127 & 47.04\% \\
      literals & 1925 & 28.96\% \\
      alias-type & 1899 & 28.56\% \\
      index-signature & 1271 & 19.12\% \\
      generics-function & 1145 & 17.22\% \\
      dot-dot-dot-token & 882 & 13.27\% \\
      call-signature & 817 & 12.29\% \\
      generics-interface & 718 & 10.80\% \\
      object & 661 & 9.94\% \\
      undefined & 577 & 8.68\% \\
      type-intersection & 431 & 6.48\% \\
      readonly & 373 & 5.61\% \\
      type-tuple & 355 & 5.34\% \\
      generics-class & 265 & 3.99\% \\
      static & 251 & 3.78\% \\
      private & 82 & 1.23\% \\
      public & 43 & 0.65\% \\
      protected & 19 & 0.29\% \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Distribution of TypeScript features in declaration files uploaded to DefinitelyTyped. The 2nd column shows how many files in DT make use of a specific TypeScript feature. The 3rd column shows the corresponding percentage for a total of 6648 declaration files in DT. Numbers were obtained from commit \texttt{da93d7b13094bacb170ead3f4a289f3b8687e4e5} (April 4, 2020).}
  \label{tab:dts-parse-stats}
\end{table}

% \paragraph*{Interfaces}
Finally, interfaces are created by exploring \texttt{getField} and \texttt{methodCall} interactions from the run-time information. We
gather the interactions for a specific argument and build the
interface by incrementally adding new properties. Interactions within
the \texttt{followingInteractions} field are recursively traversed,
building a new interface at each level up to a predefined depth. Interfaces that turn out
to be equivalent are merged.

\section{Evaluation}
\label{sec:dts-generate-evaluation}
After generating a declaration file for an \NPM{} package, we need to
evaluate its quality. To this end, we created \texttt{dts-compare}, a tool to compute the
differences between two TypeScript declaration files.
% \begin{itemize}
%   \item \texttt{dts-parse}: A TypeScript declaration files parser, which transforms the file into a JSON file with a defined structure.
%   \item \texttt{dts-compare}: A tool that uses \texttt{dts-parse} and compares two TypeScript declaration files computing differences by applying several criteria.
% \end{itemize}

For each module, we applied \texttt{dts-compare} to the generated declaration file and the
one uploaded to the DefinitelyTyped repository for the same module, as shown in
\figref{fig:evaluation-diagram}. While this approach does not provide an absolute measure
of quality, it gives us at least an indication of the pragmatics of \texttt{dts-generate}:
The files on DefinitelyTyped are perceived to be useful by the community. If the accuracy
of the generated files is comparable with the accuracy of the files on DefinitelyTyped,
then \texttt{dts-generate} is a viable alternative to manually created definition files.

\begin{changethis}
  Question: check how many files on DT are just generated by \texttt{dts-gen} (e.g., the TypeScript tool)
\end{changethis}
 
\begin{figure}[tp]
    \begin{centering}
        {\includegraphics[width=1\textwidth]{evaluation-diagram.pdf}}
        \caption[Evaluation against DefinitelyTyped Repository]{\textbf{Evaluation of
            generated declaration files against DefinitelyTyped Repository} - The parser
          uses the TypeScript Compiler           API \cite{typescript-compiler-api} to
          transform declaration files into an abstract syntax which is serialized in
          JSON. The comparison is performed on the JSON format.} 
        \label{fig:evaluation-diagram}
    \end{centering}
\end{figure}

\subsection{dts-parse}
\label{sec:dts-parse}
We need a means of comparing two declaration files. Of
course, we are not interested in a textual comparison, but in a
comparison of the structures described by the files.

The first step is to parse the declaration files, which can be
achieved by using the TypeScript Compiler API, a library which traverse the
Abstract Syntax Tree of a TypeScript program
\cite{typescript-compiler-api}. 
The step also performs a sanity check of the generated declaration
files as it rejects files with syntactic or semantics errors.
The output of \texttt{dts-parse} is a structure where declared
{interfaces}, {functions}, {classes} and
{namespaces} are stored separately. Function arguments are
correctly described, identifying complex types like union types or
callbacks. Optional parameters are also identified. For
{classes}, a distinction between the constructor and methods
is made. Declaration files are tagged according to their features, which is useful for identifying and filtering out declaration files containing unimplemented features.

\texttt{dts-parse} is itself written in TypeScript. It receives the file as input
parameter and returns an AST serialized in JSON, as shown in \coderef{code:dts-parse-example}.

\begin{lstlisting}[
  caption={Example for \texttt{dts-parse} executed on module \texttt{glob-to-regexp} and combined with \texttt{jq} to browse the returned JSON},
  language=bash,
label=code:dts-parse-example,
  float=tp, captionpos=b
]
$ dts-parse -i glob-to-regexp/index.d.ts | jq '.parsing.functions[0].name'
"GlobToRegexp"
\end{lstlisting} %$

\subsection{dts-compare}
\label{sec:dts-compare}
The tool is written in TypeScript. It takes two declaration files as input and returns a
JSON file containing the result of the comparison, as shown in
\coderef{code:dts-compare-example}. Following the naming convention of any standard Unit
Testing framework, the input files are marked as \lstinline{expected} or
\lstinline{actual}. We use \lstinline{expected} for the DefinitelyTyped
declaration files. 

\begin{lstlisting}[
  caption={Example for \texttt{dts-compare} executed on declaration files without differences},
  language=bash,
label=code:dts-compare-example,
  float=tp,captionpos=b
]
$ dts-compare -e expected.d.ts -a actual.d.ts --module-name "my-module"
{
    "module": "my-module",
    "template": "module",
    "differences": [],
    "tags": []
}
\end{lstlisting}

\texttt{dts-compare} applies \texttt{dts-parse} internally to both files to get 
normalized structures that are easy to compare. The result of the comparison is an array
of an abstract entity \texttt{Difference}.

We extracted code examples written by
developers to execute the code and gather run-time information. The quality of the
generated declaration file is heavily dependent on the code examples. For example, if a
property of an interface does not get accessed due to a code example not exploring a
particular execution path, that property will not exist in the generated declaration
file. 

To measure the impact of incomplete code examples on the
quality of generated declaration files we categorized each difference as follows: 
\begin{itemize}
  \item \texttt{solvable}: Differences that can be resolved by adding more code
    examples. For example, invoking a function with different parameters so that a missing
    interface property gets accessed. 
  \item \texttt{unsolvable}: Differences that cannot be resolved with further examples.
    % are marked as \texttt{unsolvable}. These differences are implementation errors of \texttt{dts-generate}.
\end{itemize}

The concrete evaluated differences are as follows:
\begin{itemize}
  \item \texttt{TemplateDifference}: A difference between the choice of TypeScript
    templates. For example, if the file in DefinitelyTyped is written as a \texttt{module}
    but we generated the file using the \texttt{module-function} template. The comparison
    stops if the templates differ. 
  \item \texttt{ExportAssignmentDifference}: An equality check between the export
    assignments of both files, that is in the expression \lstinline{export = XXX}. 
  \item \texttt{FunctionMissingDifference}: A function declaration is present in the expected
    file but not in the generated one. This difference applies to functions as well as methods of classes
    and interfaces. 
  \item \texttt{FunctionExtraDifference}: A function is present in the generated declaration file but not in DefinitelyTyped.
  \item \texttt{FunctionOverloadingDifference}: The number of declarations for the same
    function is different. This difference can be due to inexperience of the author of a
    declaration file, who uses, e.g., multiple declarations where a union typed argument
    would be appropriate.
  \item \texttt{ParameterMissingDifference}: A parameter of a function or a property of an interface is not present in the generated file.
  \item \texttt{ParameterExtraDifference}: A parameter of a function or a property of an
    interface is present in the generated file but not in the DefinitelyTyped file. 
  \item \texttt{ParameterTypeDifference}: A parameter of a function or a property of an interface is generated with a different type than in the DefinitelyTyped file. Here we differentiate between \texttt{SolvableDifference} and \texttt{UnsolvableDifference}.
  \begin{itemize}
    \item \texttt{SolvableDifference}: A type difference that can be solved by writing
      further code examples. For example, a basic type that is converted to a union type,
      a function overloading, or a parameter or property that is marked as optional. 
    \item \texttt{UnsolvableDifference}: Any difference not considered as \texttt{SolvableDifference}.
  \end{itemize}
\end{itemize}

Type aliases are expanded before the comparison and thus invisible to
\texttt{dts-compare}: the declaration
\lstinline{type T = string | number; declare function F(a: T);} is equivalent to
\lstinline{declare function F(a: string | number);}. The same approach applies to literal
interfaces. \texttt{dts-compare} does 
not contemplate differences in function return types, because interface inference of
function return types is not covered in the current version of \texttt{dts-generate}. 

\section{Results}
\label{sec:results}
We analyzed the obtained results focusing on the following aspects:
\begin{itemize}
  \item The quality of the inferred types, interfaces, and module structure using run-time information.
  \item The benefits of using code examples provided by developers as a first approximation to execute the libraries and avoid a cold start problem.
  \item The usability of the generated declaration file and whether \texttt{dts-generate} can be used in a proper development environment.
\end{itemize}

\begin{quotation}
  The conducted experiments included tests that consisted of replacing
  a specific type definition from DefinitelyTyped
  \cite{definitely-typed-repository} with the one generated in the
  experiments: TypeScript compilation was successful, the generated
  JavaScript code ran without errors and code intelligence features
  performed by IDEs like code completion worked as expected.
\end{quotation}

Declaration files were generated for existing modules uploaded to the
\NPM{} registry. The DefinitelyTyped repository was used as a
benchmark. Each of the generated files was compared against the
corresponding declaration file uploaded to the repository.

Figure \ref{fig:experiments-overall-funnel} shows that a declaration file was generated
for 244 modules out of 6029 modules and we identified 60 modules that have only the
features implemented by \texttt{dts-generate}. We obtained positive results for 52 of
them. Section~\ref{sec:experiments-evaluation} provides a detailed explanation of the overall
quality of the generated files.
Section~\ref{sec:experiments-declaration-files-generation} presents examples of the generated declaration files for
templates \textbf{module}, \textbf{module-class}, and \textbf{module-function}. 

\definecolor{myellow}{RGB}{228,212,0}
\definecolor{mgreen}{RGB}{5,104,57}

\newcommand\funnel[3]{%
\pgfmathsetmacro\mwid{(0.3+\val*0.06)}
\pgfmathsetmacro\mradius{(\val*0.01 + 1)}
\pgfmathsetmacro\mheight{(\val*0.003 + 0.4)}
\pgfmathsetmacro\marc{\mwid-.4}
    \begin{scope}[%
        shift={(0,#1)}, 
        line width=.05pt, 
        %x=5mm, 
        scale=0.7,
        yshift=\xi*0.05
        ]
    \draw[black,bottom color=#2, top color=#2] (-\mwid,0) -- (-\mwid+.4,-\mheight) arc (190:350:\marc cm and \mradius mm) -- (\mwid,0);
    \draw[black,fill=#3] (0,0) ellipse (\mwid cm and \mradius mm);
    \path (-\mwid,0) -- (-\mwid+.4,-\mheight) coordinate[midway] (a\xi);
    \end{scope}
}

\begin{figure}[tp]
	\hspace*{-0.16\textwidth}
	\centering
	\begin{tikzpicture}
		\foreach \val
				[%
				count=\xi starting from 0, 
				evaluate=\xi as \shadecolor using int(25*\xi),
				evaluate=\xi as \coord using int(\xi-12)
				]
			in {
				4.05,
				7.33,
				18.02,
				37.49,
				71.19,
				82.50,
				100.00
			}{
				\funnel{\coord}{mgreen!\shadecolor !myellow}{mgreen!\shadecolor !myellow}
			}   

		\node[left=0.02\textwidth of a0] {Generated Declaration Files};
		\node[right=0.04\textwidth of a0] {\textbf{244}};

		\node[left=0.02\textwidth of a1] {Run-time Information};
		\node[right=0.06\textwidth of a1] {\textbf{436}};

		\node[left=0.02\textwidth of a2] {Working Examples};
		\node[right=0.17\textwidth of a2] {\textbf{946}};

		\node[left=0.02\textwidth of a3] {Code Examples};
		\node[right=0.25\textwidth of a3] {\textbf{2260}};

		\node[left=0.02\textwidth of a4] {README file};
		\node[right=0.45\textwidth of a4] {\textbf{4292}};

		\node[left=0.02\textwidth of a5] {Github Repository};
		\node[right=0.52\textwidth of a5] {\textbf{4974}};

		\node[align=right,left=0.02\textwidth of a6, text width=0.25\textwidth] {Definitely Typed Modules};
		\node[right=0.62\textwidth of a6] {\textbf{6029}};

	\end{tikzpicture}
	\caption[Number of analyzed modules for each stage of the experiment]{\textbf{Number of analyzed modules for each stage of the experiment} - A TypeScript Declaration File was generated for only 244 modules, out of 6029 modules in the DefinitelyTyped Repository. It was possible to gather valid run-time information for only 25\% of the modules for which a Code Example was extracted.}
	\label{fig:experiments-overall-funnel}
\end{figure}

\subsection{Code Examples}
Retrieving the code examples for the JavaScript libraries proved to be
a pragmatic way of driving the type gathering at run time. However, as
shown in \figref{fig:experiments-overall-funnel}, it was only possible
to obtain working code examples for 2260 packages. The
process of getting a valid code example for a module is divided in four
stages: 
\begin{itemize}
\item extracting the repository URL;
\item extracting a README file;
\item extracting code examples from README files;
\item executing code examples and discarding failing ones.
\end{itemize}

The results obtained for each step are described in the
following sections. 

\paragraph*{Repository URL}
The URL of the source repository could be retrieved for only 4974
packages. More than 1000 packages on \NPM{} do not have a repository
entry in their corresponding \texttt{package.json} file. Therefore, the
\texttt{npm view <module> repository.url} command returns no
value. Even important modules like \texttt{ace} provide no repository URL.

\paragraph*{README Files}
700 packages do not have a README file in their repository, although
the implementation checks for several naming conventions like
\texttt{readme.md} or \texttt{README.md}. 

\paragraph*{Extraction of Code Examples}
In this step, we loose another 50\% of modules! This loss is mainly
explained because some developers do not wrap their code in a block
using the \texttt{javascript} or \texttt{js} tags. However, as we are
still left with code examples for 2200 modules, we did not further
look into code extraction as this number was considered sufficient for
evaluating the generation of declaration files. 

\paragraph*{Execution of Code Examples}
We executed the remaining 2260 extracted code examples by installing the
required packages and running the code as a \NodeJS{}
application. Unfortunately, the code examples only worked for 946
modules. 1314 modules did not run correctly and had to be
discarded. Some failing samples were analyzed and there were mainly
two reasons for the failure: 
\begin{itemize}
\item The code fragment had been properly extracted but the code was
  faulty. It invoked the library in an unsupported
  (obsolete?) way, which lead to a run-time error.
\item The extracted code fragment was not intended to be executed
  and/or it was not even valid JavaScript code. 
\end{itemize}

\paragraph*{Run-time Information}
Run-time information was extracted for only 436 out of 946 modules with working code
examples. As explained, to extract the run-time information, the behavior of the code
under analysis was explicitly modified by wrapping the arguments. Furthermore, Jalangi‚Äôs
instrumentation itself caused some executions to fail, because the modules contained
JavaScript features that are not supported by Jalangi. As a result, run-time information
could not be extracted for 510 modules. An instrumentation without user-defined analysis
modules was not applied, so it was not possible to determine which modules were failing
only because of Jalangi‚Äôs own limitations. 

\paragraph*{Generated Declaration Files}
A declaration file was generated for 244 out of 436 modules. Despite the correct execution
of the instrumented code examples, 192 modules did not yield suitable run-time information
for generating a declaration file. The extracted code examples for these modules did not
execute the library. Hence, the collected run-time information was not useful
for generating a declaration file. 

\subsection{Declaration Files Generation}
\label{sec:experiments-declaration-files-generation}

%%% !!! TBC !!!

This section exhibits some examples of the 244 generated
declaration files. It shows some results for each of the implemented
templates: \textbf{module}, \textbf{module-function}, and
\textbf{module-class}. 

\figref{fig:experiments-results-module-function} shows the generated
declaration files for simple modules like \texttt{abs},
\texttt{dirname-regex}, and \texttt{escape-html}. All of them were
generated using the \textbf{module-function} template. The left side of the figure shows
the generated declaration file with 
\lstinline{dts-generate}, the right side shows the corresponding file
in the DefinitelyTyped repository. There are no relevant
differences between the files. Functions are correctly detected; input and output types are accurately inferred.

The differences in the export assignment by modules \texttt{dirname-regex} and
\texttt{escape-html} are not problematic because the module can receive an arbitrary 
name when it is imported. \texttt{dts-generate} automatically generates the export
assignment by transforming the module name into camel case form, following TypeScript
guidelines.

The parameter names are extracted from the variable names of the JavaScript
code.
% The JavaScript implementation of module \texttt{escape-html} declares the
% first parameter of the exported function with the name \texttt{string} and not
% \texttt{text}, as specified in DefinitelyTyped. 
A difference in the names of the function parameters does not affect the correctness of
the declaration file.
Furthermore, the module \texttt{escape-html} from DefinitelyTyped declares an empty
namespace, which is not generated by our tool.
 
\begin{figure}[tp]
    \centering
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export = Abs;

declare function Abs(input: string): string;
      \end{lstlisting}
      \caption{abs/index.d.ts - Generated}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
declare function Abs(input: string): string;
export = Abs;
      \end{lstlisting}
      \caption{abs/index.d.ts - DefinitelyTyped}
    \end{subfigure}


    \begin{subfigure}{0.48\linewidth}
        \begin{lstlisting}[language=TypeScript,numbers=none]
export = DirnameRegex;

declare function DirnameRegex(): RegExp;
        \end{lstlisting}
        \caption{dirname-regex/index.d.ts - Generated}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.48\linewidth}
        \begin{lstlisting}[language=TypeScript,numbers=none]
export = dirnameRegex;

declare function dirnameRegex(): RegExp;
        \end{lstlisting}
        \caption{dirname-regex/index.d.ts - DefinitelyTyped}
      \end{subfigure}


      \begin{subfigure}{0.48\linewidth}
        \begin{lstlisting}[language=TypeScript,numbers=none]
export = EscapeHtml;

declare function EscapeHtml(string: string): string;
        \end{lstlisting}
        \caption{escape-html/index.d.ts - Generated}
      \end{subfigure}
      \hfill
      \begin{subfigure}{0.48\linewidth}
        \begin{lstlisting}[language=TypeScript,numbers=none]
declare function escapeHTML(text: string): string;
declare namespace escapeHTML { }

export = escapeHTML;
        \end{lstlisting}
        \caption{escape-html/index.d.ts - DefinitelyTyped}
      \end{subfigure}

    \caption{Results for \textbf{module-function} template}
    \label{fig:experiments-results-module-function}
\end{figure}
  

\begin{figure}[tp]
    \centering
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export function v1(str: string): boolean;
export function v2(str: string): boolean;
export function v3(str: string): boolean;
export function v4(str: string): boolean;
export function v5(str: string): boolean;
      \end{lstlisting}
      \caption{is-uuid/index.d.ts - Generated}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export function v1(value: string): boolean;
export function v2(value: string): boolean;
export function v3(value: string): boolean;
export function v4(value: string): boolean;
export function v5(value: string): boolean;
export function nil(value: string): boolean;
export function anyNonNil(value: string): boolean;
      \end{lstlisting}
      \caption{is-uuid/index.d.ts - DefinitelyTyped}
    \end{subfigure}

    \caption{Results for \textbf{module} \texttt{is-uuid}}
    \label{fig:experiments-results-module-is-uuid}
\end{figure}

An example for the \textbf{module} template
is shown for the \texttt{is-uuid} module in
\figref{fig:experiments-results-module-is-uuid}.
The generated file does not contain methods that were not executed by the extracted
examples. The invoked function are correctly detected.

Finally, we were unable to  generate a declaration file based on the
\texttt{module-class} template. All modules corresponding to this template exhibited at least one of
the unimplemented TypeScript features. 

It is worth mentioning that for some libraries the declaration file in DefinitelyTyped was
not correct. For example, for the module \texttt{glob-base}, the parameter
\texttt{basePath} is declared as optional in DefinitelyTyped. However, when invoking the
function without the \texttt{basePath} parameter, an error is thrown at run time. The file generated by
\texttt{dts-generate} does not mark this parameter as optional, as shown in
\figref{fig:experiments-results-module-glob-base}. Function return type interfaces are
not inferred by \texttt{dts-generate}. The parameter name is \texttt{pattern}
instead of \texttt{basePath}, because the JavaScript implementation declares the parameter
as \texttt{pattern}, as shown in \figref{fig:subfloat-globbase-js-implementation}. We also
discovered errors in the selected template in DefinitelyTyped. The module
\texttt{smart-truncate} in DefinitelyTyped uses the \texttt{module} template, but
\texttt{dts-generate} generates a file using the \texttt{module-function}
template. \coderef{code:experiments-results-module-smart-truncate} shows that the module is indeed
exported as a function, as inferred by \texttt{dts-generate}.

\begin{figure}[tp]
    \centering
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
export = GlobBase;

declare function GlobBase(pattern: string): object;
      \end{lstlisting}
      \caption{glob-base/index.d.ts - Generated}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
declare function globbase(basePath?: string): globbase.GlobBaseResult;

declare namespace globbase {
    interface GlobBaseResult {
        base: string;
        isGlob: boolean;
        glob: string;
    }
}

export = globbase;
      \end{lstlisting}
      \caption{glob-base/index.d.ts - DefinitelyTyped}
    \end{subfigure}

    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=JavaScript,numbers=none]
var globBase = require('glob-base');

globBase();

// Throws: TypeError: glob-base expects a string.
      \end{lstlisting}
      \caption{Code example invoking the exported function without the first parameter, as specified in DefinitelyTyped}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
      \begin{lstlisting}[language=TypeScript,numbers=none]
'use strict';

// ...

module.exports = function globBase(pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob-base expects a string.');
  }

  // ...
} 
      \end{lstlisting}
      \caption{glob-base/index.js - Fraction of JS implementation that throws an Error when input parameter is not a string}
      \label{fig:subfloat-globbase-js-implementation}
    \end{subfigure}

    \caption{Incorrect optional parameter for module \texttt{glob-base}}
    \label{fig:experiments-results-module-glob-base}
\end{figure}

\begin{lstlisting}[
  caption={Code example for \texttt{smart-truncate} module exporting a function},
  label=code:experiments-results-module-smart-truncate,
  language=JavaScript,captionpos=b,float=tp,numbers=none
]
var smartTruncate = require('smart-truncate');

var string = 'To iterate is human, to recurse divine.';

// Append an ellipsis at the end of the truncated string.
var truncated = smartTruncate(string, 15);
\end{lstlisting}

\subsection{Evaluation}
\label{sec:experiments-evaluation}
We analyzed 60 of the 244 generated files. The remaining 184 files contained at least one
of the unimplemented TypeScript features so that they could not be considered. These
features were identified by \texttt{dts-parse} as tags.


As shown in \figref{fig:experiments-results-module-is-uuid}, the code examples have a
direct influence on the quality of the generated declaration file. We introduced the
concept of \texttt{solvable} and \texttt{unsolvable} differences in
\secref{sec:dts-compare}. Modules containing only \texttt{solvable} differences were
considered as positive results. We identified 52 such modules. We manually completed the
examples for 10 of those modules. Applying \texttt{dts-generate} with the completed
examples generates declaration files, which are equivalent to the files from DefinitelyTyped, as
shown in \figref{fig:experiments-results-manually-completed-examples}.

\begin{figure}[tp]
  \centering
  \begin{subfigure}{0.80\linewidth}
    \begin{lstlisting}[language=TypeScript]
declare namespace gh {
  interface Options {
      enterprise?: boolean;
  }
  interface Result {
      user: string;
      repo: string;
      branch: string;
      https_url: string;
      tarball_url: string;
      clone_url: string;
      travis_url: string;
      api_url: string;
      zip_url: string;
  }
}

declare function gh(url: string | {url: string}, options?: gh.Options): gh.Result | null;

export = gh;    
    \end{lstlisting}
    \caption{github-url-to-object/index.d.ts - DefinitelyTyped}
  \end{subfigure}

  \begin{subfigure}{0.80\linewidth}
    \begin{lstlisting}[language=TypeScript]
export = GithubUrlToObject;

declare function GithubUrlToObject(repoUrl: string | GithubUrlToObject.I__repoUrl, opts?: GithubUrlToObject.I__opts): object | null;
declare namespace GithubUrlToObject {
  export interface I__repoUrl {
    'url'?: string;
  }

  export interface I__opts {
    'enterprise'?: boolean;
  }

}
    \end{lstlisting}
    \caption{github-url-to-object/index.d.ts - Generated with manually expanded code example}
  \end{subfigure}

  \begin{subfigure}{0.80\linewidth}
    \begin{lstlisting}[language=JavaScript]
var gh = require('github-url-to-object')

gh('github:monkey/business');
gh('https://github.com/monkey/business');
gh('https://github.com/monkey/business/tree/master');
gh('https://github.com/monkey/business/tree/master/nested/file.js');
gh('https://github.com/monkey/business.git');
gh('http://github.com/monkey/business');
gh('git://github.com/monkey/business.git');

// Manually added:
gh('git+https://githuuub.com/monkey/business.git', {});
gh('git+https://githuuub.com/monkey/business.git', {enterprise: true});
gh({url: 'git://github.com/monkey/business.git'});
gh('this is not a proper url');
gh({url: 'this is not a proper url'});
    \end{lstlisting}
    \caption{Code example for module \texttt{github-url-to-object}.}
    \end{subfigure}
  \caption{Manually expanded code example for \texttt{github-url-to-object} to match DefinitelyTyped declaration file. Literal interface in DefinitelyTyped gets replace by a declared interface. Return types are not considered.}
  \label{fig:experiments-results-manually-completed-examples}
\end{figure}

We discovered only 8 modules with \texttt{unsolvable} differences. Most of them were
caused by the same error: 7 modules incorrectly declared an interface for the
\texttt{string} type. This interface contains standard properties and methods from the
JavaScript \texttt{String} object, such as \texttt{length} or \texttt{indexOf()}.

\section{Discussion}
\label{sec:discussion}

How can we improve further? Given that JavaScript developers are more incentivized to develop good
examples than writing ``boring'' type declaration, how can we capitalize on that attitude?
The main issue is that any example-driven algorithm can only come up with an
under-approximation of the intended meaning, so some form of help is required when
generalization is desired.

\paragraph*{Literal types vs string}
JavaScript libraries often (?) use literal strings to select
options and configurations. For example, \dots

For our framework, it is hard to distinguish a string that is meant literally from a
string that just serves as an example. For an automatic solution, one might collect
typical values of literal strings and generate the corresponding literal types (or
unions thereof) when the arguments used in the example are all typical. Alternatively, one
might always generate literal types unless the number of different examples provided is
greater than some threshold, in which case the generator generalizes to type
\lstinline/string/. A further alternative would be to communicate to the developer a set
of typical example strings, \emph{marker strings}, that the generator always resolves to the \lstinline/string/
type.

\paragraph*{Any}
Suppose the programmer supplies examples that use \lstinline/number/, \lstinline/bool/, and
\lstinline/string/ at the same argument position. The obvious approximation to the type of
this argument is the union type \lstinline/number|bool|string/. But what if the programmer
wants to advertise the type \lstinline/any/ for an argument? This intent is hard to
advertise with a finite number of examples.

We propose that the programmer relies on marker strings like \lstinline/"any"/ to indicate
the \lstinline/any/ type for an argument position.

\paragraph*{Further types}
Similar approaches could be conceived for indexed types, polymorphic types, dependent
types, etc. However, at present we believe incorporating these features in a tool to be
overblown because they are not widely used in DefinitelyTyped (see
Table~\ref{tab:dts-parse-stats}). 

\section{Related Work}
\label{sec:related-work}
\paragraph*{Microsoft's dts-gen}
Microsoft developed \texttt{dts-gen}, a tool that creates declaration files for
JavaScript libraries \cite{dts-gen}. Its documentation states that the result is 
intended to be used a starting point for development of a declaration file. The outcome
needs to be refined afterwards by the developer. 

The tool analyzes the shape of the objects at runtime after initialization without
executing the library. This results in many variables being inferred as
\lstinline[language={}]{any}. \coderef{code:related-work-dts-gen-example} shows an example
for module \lstinline[language={}]{abs}. 

In contrast, our tool \texttt{dts-generate} is intended to generate declaration files
that are ready to be uploaded to DefinitelyTyped without further manual intervention. Any
amount of manual work that a developer needs to do on a declaration file after updating
JavaScript code increases the risk for having discrepancies between the declaration file
and the implementation.

% Formal aspects like applying the right template and using the correct syntax are perfectly covered by \texttt{dts-gen}.

\begin{lstlisting}[
    language=bash,
    caption={Microsoft's dts-gen example - A declaration file for module \lstinline!abs! is generated. Types are inferred as \lstinline!any!. The correct \lstinline!module-function! template is used.},
	label=code:related-work-dts-gen-example,
    float=tp,captionpos=b
]
$ npm i -g dts-gen
$ npm i -g abs
$ dts-gen -m abs
Wrote 5 lines to abs.d.ts.

$ cat abs.d.ts
/** Declaration file generated by dts-gen */

export = abs;

declare function abs(input: any): any;
\end{lstlisting}

\paragraph*{TSInfer \& TSEvolve}
TSInfer and TSEvolve are presented as part of TSTools
\cite{DBLP:conf/fase/KristensenM17}. Both tools are the continuation of TSCheck
\cite{DBLP:conf/oopsla/FeldthausM14}, a tool for detecting mismatches between a
declaration file and the implementation of the module. 

TSInfer proceeds in a similar way than TSCheck. It initializes the library in a browser
and records a snapshot of the resulting state.  Then it performs a lightweight static
analysis on all the functions and objects stored in the snapshot. 

The abstraction and the constraints introduced as part of the static analysis tools
for inferring the types have room for improvement. A run-time based approach like the one
presented in our work will provide more accurate information, thus generating more precise
declaration files.

As TSInfer analyzes the objects and functions stored in the snapshot, it faces the problem
of including internal methods and private properties in the declaration file. Run-time
information would have informed that the developer has no intention of exposing these
methods. 

Moreover, TSEvolve performs a differential analysis on the changes made to a JavaScript
library to determine intentional discrepancies between the declaration files of two
consecutive versions. However, a differential analysis may not be needed. If the
developer's intention were accurately represented by the extracted code, then the generated
declaration file would already describe the newer version of a library without the need of
a differential analysis.

\paragraph*{TSTest}
TSTest is a tool that checks for mismatches between a declaration file and the JavaScript
implementation of the module \cite{DBLP:journals/pacmpl/KristensenM17}. It applies feedback-directed
random testing for generating type test scripts. These scripts execute the library with
random arguments with the typings from the declarations file and check whether the output
matches the prescribed type. TSTest thus provides concrete counterexamples if it detects mismatches.

% We evaluated the generated declaration files comparing them to the declaration files
% uploaded to DefinitelyTyped. The disadvantage of doing this is that since the uploaded
% files are written manually, they could already contain mismatches with the JavaScript
% implementation. However, it is a suitable choice for a development stage since it is used
% as a baseline.

% In a final stage, declaration files need to be checked against the proper JavaScript
% implementation and TSTest has to be definitely taken into account. 

TSTest could be used to extend our tool with a feedback loop. If TSTest detects a problem
with a declaration file generated by \texttt{dts-generate}, then we would add the
resulting counterexamples to the example code and restart the generation process. 

\section{Conclusions and Future Work}
\label{sec:conclusion}
We have presented \texttt{dts-generate}, a tool for generating a TypeScript declaration
file for a specific JavaScript library. The tool downloads code examples written by the
developers from the library's repository. It uses these examples to execute the library and
gather data flow and type information. The tool finally generates a TypeScript declaration
file based on the information gathered at run time.

We developed an architecture that supports the automatic generation of declaration files
for specific JavaScript libraries without additional manual tasks. The architecture
contemplates future incorporation of a Symbolic Execution Engine that refines the
initial code base enabling the exploration of new execution paths. Although it is not
implemented 
in this work, its incorporation would result in small incremental modifications to the
presented architecture as it is considered to only expand the existing code base.

Building an end-to-end solution for the generation of TypeScript declaration files was
prioritized over type inference accuracy. Consequently, types were taken over from the
values at run time. Developers express their intent how a library should be used with
example code in the documentation. Hence,
obtaining the types from the code examples extracted from the repositories proved to be a
pragmatic and effective approximation, enabling to work on specific aspects regarding the
TypeScript declaration file generation itself.

We built a mechanism to automatically create declaration files for potentially every
module uploaded to DefinitelyTyped. We managed to generate declaration files for 244
modules. We compared the results against the corresponding files uploaded to
DefinitelyTyped by creating \texttt{dts-parse}, a TypeScript declaration files parser and
\texttt{dts-compare}, a comparator.

\begin{changethis}
  We exposed the fundamental aspect of capturing the developer's intention when inferring
  types in JavaScript. Instead of applying constraints and restrictions for operations
  with certain types, we presented a proposal that favors best practice. Uncommon usage is
  not forbidden but greatly discouraged. Accordingly, we collected evidence regarding the
  usage of JavaScript operators by analyzing 400 libraries.
\end{changethis}
% Finally, the architecture is composed of different blocks that interact with each
% other. Each block is independent and has a well defined behavior as well as clear input
% and output values. As a result, each block can be independently and simultaneously
% improved.

\printbibliography
%%\bibliography{main}

\end{document}
