\chapter{Conclusion}\label{chap:conclusion}

We have presented \mintinline{text}{dts-generate}, a tool for generating a TypeScript declaration file for a specific JavaScript library. The tool downloads code samples written by the developers from the library's repository. It uses these samples to execute the library and gather data flow and type information. The tool finally generates a TypeScript declaration file based on the information gathered at run-time.

We developed an architecture that supports the automatic generation of declaration files for specific JavaScript libraries without additional manual tasks. The architecture contemplates a future incorporation of a Symbolic Execution Engine that refines the initial code base enabling the exploration of new execution paths. However not implemented in this work, its incorporation would result in small incremental modifications to the presented architecture as it is considered to only expand the existing code base.

Building and end-to-end solution for the generation of TypeScript declaration files was prioritized over type inference accuracy. Consequently, types were taken over from the values at run-time. Obtaining the types from the code examples extracted from the repositories proved to be a pragmatic and effective approximation, enabling to work on specific aspects regarding the TypeScript declaration file generation.

We built a mechanism to automatically create declaration files for every module uploaded to DefinitelyTyped and evaluate the results, creating a TypeScript declaration files parser and a comparator.

We exposed the fundamental aspect of capturing the developer's intention when inferring types in JavaScript. Instead of applying constraints and restrictions for operations with certain types, we presented a proposal where common practices are favored. Uncommon usage is not forbidden but greatly disfavored. Used in a first place merely as an initial code base for executing the library and approximating types, code examples turned out to be extremely useful for inferring types. They expose the developer's intention explicitly through code.


Finally, the architecture is composed of different blocks that interact with each other. Each block is independent and has a well defined behavior as well as clear input and output values. As a result, each block can be independently and simultaneously improved.

\section{Future Work} \label{sec:conclusions-future-work}

\subsection{Instrumentation}
\draft{Babel}

\subsection{Declaration files generation}
\draft{Optional parameters}
\draft{Functions as paramters}
\subsubsection{Uploading Results to Definitely Typed Repository}


\subsection{Type Inference}
% \todo{Deberia ser hecho en otro modulo que no sea el runtime information. El runtime information deberia exponer unicamente los datos que le hacen falta al otro para inferir los tipos.}

% \todo{Tambien se puede identificar patterns de programacion donde siempre los tipos son los mismos!!! El concepto de inferir el tipo en realidad pasa a detectar la intencion del developer.}

\subsubsection{Return values}
% \todo{El return value se podria incluir en el analysis de Jalangi, detectando las interactions que tiene etc etc. Esto no es tan facil porque no se puede simplemente inspeccionar el return value, sino que hay que saber para qué se usa. Los ejemplos podrían ser útiles}.

\subsubsection{Variable Names}
% \todo{Se puede extraer info del nombre de las variables y del nombre de los metodos, etc. La developer's intention.}

\subsubsection{Variable Content}

\subsubsection{Function Names}